#include <iostream>
#include <pthread.h>
#include "display.h"
#include "time.h"
#include "physics.h"
#include "mesh.h"

#define NUM_THREADS 4

struct Camera
{
	Vector3f pos;
	float fov;
};

//static Vector3f g_cameraPos;//(0,0,-2);
//static const float g_FOV = ToRadians(70.0f);

static Mesh* g_mesh;

inline bool IntersectScene(const Vector3f& origin, const Vector3f& direction, RayIntersectData* isectData)
{
	return g_mesh->IntersectRay(origin, direction, isectData);
}

inline Vector3f Sample(const Vector3f& origin, const Vector3f& direction)
{
	RayIntersectData isectData;
	
	if(IntersectScene(origin, direction, &isectData))
	{
		return Vector3f(1 - isectData.u - isectData.v, isectData.u, isectData.v);
		//return Vector3f(1,1,1) - (Vector3f(-isectData.t, -isectData.t, -isectData.t) / 1.4f);
	}
	
	return Vector3f(0,0,0);
}

struct RenderDisplayArgs
{
	Bitmap* display;
	Camera* camera;
	int xStart;
	int xEnd;
	int yStart;
	int yEnd;
};

void* RenderDisplaySubset(void* args)
{
	RenderDisplayArgs dispArgs = *((RenderDisplayArgs*)args);
	Bitmap* display = dispArgs.display;
	Camera* camera = dispArgs.camera;
	int xStart = dispArgs.xStart;
	int xEnd = dispArgs.xEnd;
	int yStart = dispArgs.yStart;
	int yEnd = dispArgs.yEnd;

	unsigned int displayWidth = display->GetWidth();
	unsigned int displayHeight = display->GetHeight();

	float ar = (float)displayWidth/displayHeight;
	
	float x = ((2.0f * ar * (float)xStart)/(float)displayWidth - ar);
	float y = -((2.0f * (float)yStart)/(float)displayHeight - 1.0f);
	
	float xDist = ((2.0f * ar * (float)xEnd)/(float)displayWidth - ar) - x;
	float yDist = -((2.0f * (float)yEnd)/(float)displayHeight - 1.0f) - y;
	
	float xStep = (xDist)/(float)(xEnd - xStart);
	float yStep = (yDist)/(float)(yEnd - yStart);
	
	RayIntersectData tempData;
	
	float yInit = y;
	for(unsigned int i = xStart; i < xEnd; i++)
	{
		for(unsigned int j = yStart; j < yEnd; j++)
		{
			display->DrawPixel(i, j, Sample(camera->pos * -1, Vector3f(x,-y,camera->fov)));
			y += yStep;
		}
		x += xStep;
		y = yInit;
	}
	
	return NULL;
}

void Render(Bitmap* display, Camera* camera)
{
	pthread_t threads[NUM_THREADS];
	int iret[NUM_THREADS];
	RenderDisplayArgs args[NUM_THREADS];
	
	float screenDivWidth = (float)display->GetWidth()/(float)NUM_THREADS;
	float screenDivHeight = (float)display->GetHeight()/(float)NUM_THREADS;
	
	for(int i = 0; i < NUM_THREADS; i++)
	{
		args[i].display = display;
		args[i].camera = camera;
		args[i].xStart = 0;
		args[i].xEnd = display->GetWidth();
		args[i].yStart = (int)(i*screenDivHeight);
		args[i].yEnd = (int)((i + 1)*screenDivHeight);

//		args[i].display = display;
//		args[i].xStart = (int)(i*screenDivWidth);
//		args[i].xEnd = (int)((i + 1)*screenDivWidth);
//		args[i].yStart = 0;
//		args[i].yEnd = display->GetHeight();
		
		iret[i] = pthread_create(&threads[i], NULL, RenderDisplaySubset, (void*)(&args[i]));
	}
	
	for(int i = 0; i < NUM_THREADS; i++)
		pthread_join(threads[i], NULL);
}

int main()
{
	//Display display(320, 240, 3, "My 3D application");
	Display display(800, 600, 1, "My 3D application");
	//Display display(1280, 720, 1, "My 3D application");
	
	Camera camera;
	camera.pos = Vector3f(0,0,-2);
	camera.fov = ToRadians(70.0f);
	
	g_mesh = new Mesh("./res/monkey0.obj");
	
	while(!display.IsClosed())
	{
		double startTime = Time::GetTime();
		
		Render(&display.GetRaster(), &camera);
		
		double frameTime = Time::GetTime() - startTime;
		std::cout << "Render time: " << frameTime*1000.0 << " ms" << std::endl;
		display.Update();
	}

	display.GetRaster().Save("output.ppm");

	delete g_mesh;
	
    return 0;
}
